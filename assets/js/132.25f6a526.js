(window.webpackJsonp=window.webpackJsonp||[]).push([[132],{494:function(e,t,r){"use strict";r.r(t);var a=r(8),o=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[e._v("提示")]),e._v(" "),t("p",[e._v("本文主要对启动容器过程中最核心的refresh()函数进行解析")])]),e._v(" "),t("h2",{attrs:{id:"_1-preparerefresh"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-preparerefresh"}},[e._v("#")]),e._v(" 1. prepareRefresh()")]),e._v(" "),t("blockquote",[t("p",[t("strong",[e._v("刷新前的预处理")])])]),e._v(" "),t("ol",[t("li",[e._v("this.closed.set(false)，this.active.set(true)  设置一些标记位")]),e._v(" "),t("li",[e._v("initPropertySources()初始化一些属性设置;(交由子类去实现，比如web容器中的 AbstractRefreshableWebApplicationContext 就去初始化了servlet的一些init参数等等)")]),e._v(" "),t("li",[e._v("getEnvironment().validateRequiredProperties();检验属性的合法等")]),e._v(" "),t("li",[e._v("earlyApplicationEvents= new LinkedHashSet"),t("ApplicationEvent",[e._v("();初始化容器，保存一些早期的事件；")])],1)]),e._v(" "),t("h2",{attrs:{id:"_2-obtainfreshbeanfactory"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-obtainfreshbeanfactory"}},[e._v("#")]),e._v(" 2. obtainFreshBeanFactory()")]),e._v(" "),t("blockquote",[t("p",[t("strong",[e._v("获取BeanFactory,注册配置文件中的Bean定义")])])]),e._v(" "),t("ol",[t("li",[e._v("refreshBeanFactory(): 抽象方法，子类【AbstractRefreshableApplicationContext】唯一实现的："),t("br"),e._v("\n① 若已经存在beanFactory了，那就做一些清理工作（销毁单例Bean、关闭工厂）"),t("br"),e._v("\n② 创建了一个this.beanFactory = new "),t("strong",[e._v("DefaultListableBeanFactory")]),e._v("();并且设置id"),t("br"),e._v("\n③ 把旧的工厂的属性赋值给新创建的工厂：customizeBeanFactory(beanFactory)"),t("br"),e._v("\n④ loadBeanDefinitions(beanFactory)："),t("strong",[e._v("加载Bean定义")]),e._v("。抽象方法，由子类去决定从哪儿去把Bean定义加载进来，实现有比如：\n"),t("ul",[t("li",[t("strong",[e._v("XmlWebApplicationContext")]),e._v("：专为web设计的从xml文件里加载Bean定义（借助XmlBeanDefinitionReader）")]),e._v(" "),t("li",[t("strong",[e._v("ClassPathXmlApplicationContext/FileSystemXmlApplicationContext")]),e._v("：均由父类 AbstractXmlApplicationContext去实现这个方法的，也是借助XmlBeanDefinitionReader")]),e._v(" "),t("li",[t("strong",[e._v("AnnotationConfigWebApplicationContext")]),e._v("：基于注解驱动的容器。（也是当下最流行、最重要的一个实现，前面一篇博文对此有重点分析），借助了AnnotatedBeanDefinitionReader.register()方法加载Bean定义")])])])]),e._v(" "),t("blockquote",[t("p",[e._v("（这里面需要注意的是：.register()只是把当前这一个Class对象registry.registerBeanDefinition()了，至于内部的@Bean、@ComponentScan扫描到的，都不是在此处注册的")])]),e._v(" "),t("blockquote",[t("p",[e._v("有必要说一句：AnnotationConfigApplicationContext是在非web环境下的容器。它虽然没有实现实现loadBeanDefinitions()抽象方法，是因为它在new对象的时候，已经调用了.register()完成配置Bean定义信息的注册了")])]),e._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[e._v("getBeanFactory(): 返回刚才GenericApplicationContext创建的BeanFactory对象；")]),e._v(" "),t("li",[e._v("将创建的BeanFactory【DefaultListableBeanFactory】返回；")])]),e._v(" "),t("p",[t("mark",[e._v("到这一步截止，BeanFactory已经创建好了（只不过都还是默认配置而已），配置Bean的定义信息也注册好了")])]),e._v(" "),t("h2",{attrs:{id:"_3-preparebeanfactory-beanfactory"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-preparebeanfactory-beanfactory"}},[e._v("#")]),e._v(" 3. prepareBeanFactory(beanFactory)")]),e._v(" "),t("blockquote",[t("p",[t("strong",[e._v("BeanFactory的预准备工作（对BeanFactory进行一些设置）")])])]),e._v(" "),t("ol",[t("li",[e._v("设置BeanFactory的类加载器、StandardBeanExpressionResolver、ResourceEditorRegistrar")]),e._v(" "),t("li",[e._v("添加感知后置处理器BeanPostProcessor【ApplicationContextAwareProcessor】,并设置一些忽略EnvironmentAware、EmbeddedValueResolverAware、xxxxx（因为这个处理器都一把抓了）")]),e._v(" "),t("li",[e._v("注册【可以解析的(表示虽然不在容器里，但还是可以直接 @Auwowired)】自动装配；我们能直接在任何组件中自动注入(@Autowired)：BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext")]),e._v(" "),t("li",[t("strong",[e._v("添加BeanPostProcessor")]),e._v("【ApplicationListenerDetector】 检测注入进来的Bean是否是监听器")]),e._v(" "),t("li",[e._v('Detect a LoadTimeWeaver and prepare for weaving, if found.添加编译时的AspectJ支持：LoadTimeWeaverAwareProcessor\n(添加的支持的条件是：beanFactory.containsBean("loadTimeWeaver"))')]),e._v(" "),t("li",[e._v("给BeanFactory中注册一些能用的组件；\n"),t("ul",[t("li",[e._v("environment--\x3e【ConfigurableEnvironment】、")]),e._v(" "),t("li",[e._v("systemProperties--\x3e【Map<String, Object>】、")]),e._v(" "),t("li",[e._v("systemEnvironment--\x3e【Map<String, Object>】")])])])]),e._v(" "),t("h2",{attrs:{id:"_4-postprocessbeanfactory-beanfactory"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-postprocessbeanfactory-beanfactory"}},[e._v("#")]),e._v(" 4. postProcessBeanFactory(beanFactory)")]),e._v(" "),t("blockquote",[t("p",[t("strong",[e._v("BeanFactory准备工作完成后进行的后置处理工作（由子类完成）")])])]),e._v(" "),t("p",[e._v("一般web容器都会对应的实现此方法，比如 AbstractRefreshableWebApplicationContext：")]),e._v(" "),t("ol",[t("li",[e._v("添加感知BeanPostProcessor【ServletContextAwareProcessor】，支持到了ServletContextAware、ServletConfigAware")]),e._v(" "),t("li",[e._v("注册scopse：beanFactory.registerScope(WebApplicationContext.SCOPE_REQUEST, new RequestScope());当然还有SCOPE_SESSION、SCOPE_APPLICATION")]),e._v(" "),t("li",[e._v("向上线一样，注册【可以解析的】自动注入依赖：ServletRequest/ServletResponse/HttpSession/WebRequest\n(备注：此处放进容器的都是xxxObjectFactory类型，所以这是为何@Autowired没有线程安全问题的重要一步)")]),e._v(" "),t("li",[e._v("registerEnvironmentBeans：注册环境相关的Bean（使用的registerSingleton，是直接以单例Bean放到容器里面了）\n"),t("ul",[t("li",[e._v("servletContext--\x3e【ServletContext】")]),e._v(" "),t("li",[e._v("servletConfig--\x3e【ServletConfig】")]),e._v(" "),t("li",[e._v("contextParameters--\x3e【Map<String, String>】 保存有所有的init初始化参数（getInitParameter）")]),e._v(" "),t("li",[e._v("contextAttributes--\x3e【Map<String, Object>】 servletContext的所有属性（ServletContext#getAttribute(String)）")])])])]),e._v(" "),t("p",[t("mark",[e._v("以上是BeanFactory的创建及预准备工作，至此准备工作完成了，那么接下来就得利用工厂干点正事了")])]),e._v(" "),t("h2",{attrs:{id:"_5-invokebeanfactorypostprocessors-beanfactory"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-invokebeanfactorypostprocessors-beanfactory"}},[e._v("#")]),e._v(" 5. invokeBeanFactoryPostProcessors(beanFactory)")]),e._v(" "),t("blockquote",[t("p",[t("strong",[e._v("执行BeanFactoryPostProcessor的方法（第四步中已经注册了此处理器）")])])]),e._v(" "),t("p",[e._v("BeanFactoryPostProcessor：BeanFactory的后置处理器。此处调用，现在就表示在BeanFactory标准初始化之后执行的；")]),e._v(" "),t("p",[e._v("两个接口：BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor（子接口）")]),e._v(" "),t("ol",[t("li",[e._v("执行BeanFactoryPostProcessor们的方法；"),t("br"),e._v(" "),t("strong",[e._v("先执行BeanDefinitionRegistryPostProcessor")]),e._v(" "),t("ul",[t("li",[e._v("获取所有的BeanDefinitionRegistryPostProcessor；（当然会最先执行我们手动set进去的Processor，但是这个一般都不会有）")]),e._v(" "),t("li",[e._v("先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor、postProcessor.postProcessBeanDefinitionRegistry(registry)")]),e._v(" "),t("li",[e._v("在执行实现了Ordered顺序接口的BeanDefinitionRegistryPostProcessor")]),e._v(" "),t("li",[e._v("最后执行没有实现任何优先级或者是顺序接口的BeanDefinitionRegistryPostProcessors")])])])]),e._v(" "),t("p",[t("strong",[e._v("都会调用getBean(“name”,BeanDefinitionRegistryPostProcessor.class)方法，所以都会先实例化后处理器，再执行")])]),e._v(" "),t("div",{staticClass:"custom-block note"},[t("p",{staticClass:"custom-block-title"},[e._v("笔记")]),e._v(" "),t("p",[e._v("这里面需要特别的介绍一个处理器："),t("code",[e._v("ConfigurationClassPostProcessor")]),e._v("，它是一个BeanDefinitionRegistryPostProcessor它会解析完成所有的@Configuration配置类，然后所有@Bean、@ComponentScan等等Bean定义都会搜集进来了，所以这一步是非常的重要的。需要注意的是这个时候注册进来的bean还没有实例化。")])]),e._v(" "),t("p",[t("strong",[e._v("再执行BeanFactoryPostProcessor的方法（顺序逻辑同上，略）")])]),e._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[e._v("再次检测一次添加对AspectJ的支持。为何还要检测呢？through an @Bean method registered by ConfigurationClassPostProcessor，这样我们注入了一个切面Bean，就符合条件了嘛")])]),e._v(" "),t("p",[t("mark",[e._v("上面5个步骤，已经Bean工厂完全准备好了，并且也注册好了所有的Bean的定义信息（此时Bean还并没有创建）")])]),e._v(" "),t("h2",{attrs:{id:"_6-registerbeanpostprocessors-beanfactory"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-registerbeanpostprocessors-beanfactory"}},[e._v("#")]),e._v(" 6. registerBeanPostProcessors(beanFactory)")]),e._v(" "),t("blockquote",[t("p",[t("strong",[e._v("注册BeanPostProcessor（Bean的后置处理器）,实现在bean的初始化前后进行一些操作")])])]),e._v(" "),t("p",[t("strong",[e._v("不同接口类型的BeanPostProcessor；在Bean创建前后的执行时机是不一样的")])]),e._v(" "),t("ul",[t("li",[e._v("BeanPostProcessor：BeanPostProcessor是一个工厂钩子，允许Spring框架在"),t("strong",[e._v("新创建Bean实例时对其进行定制化修改")]),e._v("，比如填充Bean、创建代理、解析Bean内部的注解等等")]),e._v(" "),t("li",[e._v("DestructionAwareBeanPostProcessor：Bean销毁时候")]),e._v(" "),t("li",[e._v("InstantiationAwareBeanPostProcessor：Bean初始化的时候")]),e._v(" "),t("li",[e._v("SmartInstantiationAwareBeanPostProcessor：初始化增强版本：增加了一个对Bean类型预测的回调（一般是Spring内部使用，调用者还是使用InstantiationAwareBeanPostProcessor就好）")]),e._v(" "),t("li",[e._v("MergedBeanDefinitionPostProcessor：合并处理Bean定义的时候的回调【该类型的处理器保存在名为internalPostProcessors的List中】")])]),e._v(" "),t("ol",[t("li",[e._v("获取所有的 BeanPostProcessor;后置处理器都默认可以通过PriorityOrdered、Ordered接口来执行优先级")]),e._v(" "),t("li",[e._v("先注册PriorityOrdered优先级接口的BeanPostProcessor: 把每一个BeanPostProcessor添加到BeanFactory中")]),e._v(" "),t("li",[e._v("再注册Ordered接口的、最后注册没有实现任何优先级接口的、最终注册MergedBeanDefinitionPostProcessor")])]),e._v(" "),t("blockquote",[t("p",[e._v("🔎此处细节：BeanPostProcessor本身也是一个Bean，其注册之前一定先实例化，而且是分批实例化和注册")])]),e._v(" "),t("h2",{attrs:{id:"_7-initmessagesource"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-initmessagesource"}},[e._v("#")]),e._v(" 7. initMessageSource()")]),e._v(" "),t("blockquote",[t("p",[t("strong",[e._v("初始化MessageSource组件（做国际化功能；消息绑定，消息解析）")])])]),e._v(" "),t("ol",[t("li",[e._v("看容器中是否有id为messageSource的，类型是MessageSource的组件,如果有赋值给messageSource，如果没有自己创建一个DelegatingMessageSource；")]),e._v(" "),t("li",[e._v("把创建好的MessageSource注册在容器中，以后获取国际化配置文件的值的时候，可以自动注入MessageSource")])]),e._v(" "),t("h2",{attrs:{id:"_8-initapplicationeventmulticaster"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-initapplicationeventmulticaster"}},[e._v("#")]),e._v(" 8. initApplicationEventMulticaster()")]),e._v(" "),t("blockquote",[t("p",[t("strong",[e._v("初始化事件派发器")])])]),e._v(" "),t("ol",[t("li",[e._v("从BeanFactory中获取applicationEventMulticaster的ApplicationEventMulticaster；")]),e._v(" "),t("li",[e._v("如果上一步没有配置；创建一个SimpleApplicationEventMulticaster,将创建的ApplicationEventMulticaster添加到BeanFactory中")])]),e._v(" "),t("h2",{attrs:{id:"_9-onrefresh"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-onrefresh"}},[e._v("#")]),e._v(" 9. onRefresh()")]),e._v(" "),t("blockquote",[t("p",[t("strong",[e._v("留给子容器（子类） 容器刷新的时候做些事")])])]),e._v(" "),t("h2",{attrs:{id:"_10-registerlisteners"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-registerlisteners"}},[e._v("#")]),e._v(" 10. registerListeners()")]),e._v(" "),t("blockquote",[t("p",[t("strong",[e._v("把容器中将所有项目里面的ApplicationListener注册进来")])])]),e._v(" "),t("ol",[t("li",[e._v("拿到容器里所有的Bean定义的名字，类型为ApplicationListener，然后添加进来:getApplicationEventMulticaster().addApplicationListener(listener);")]),e._v(" "),t("li",[e._v("派发之前步骤产生的事件（早期事件）")])]),e._v(" "),t("p",[e._v("🔎"),t("strong",[e._v("细节：此处只是把Bean的名字放进去，Bean还没有实例化哦")])]),e._v(" "),t("h2",{attrs:{id:"_11-finishbeanfactoryinitialization-beanfactory"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11-finishbeanfactoryinitialization-beanfactory"}},[e._v("#")]),e._v(" 11. finishBeanFactoryInitialization(beanFactory)")]),e._v(" "),t("blockquote",[t("p",[t("strong",[e._v("初始化所有剩下的单实例bean（主要是自定义的一些Bean)；这应该是最核心的一步了")])])]),e._v(" "),t("ol",[t("li",[e._v("为容器初始化ConversionService(容器若没有就不用初始化了,依然采用getBean()初始化的) 提供转换服务")]),e._v(" "),t("li",[e._v("若没有设置值解析器，那就注册一个默认的值解析器（lambda表示的匿名处理）")]),e._v(" "),t("li",[e._v("实例化LoadTimeWeaverAware(若存在)")]),e._v(" "),t("li",[e._v("清空临时类加载器：beanFactory.setTempClassLoader(null)")]),e._v(" "),t("li",[e._v("缓存（快照）下当前所有的Bean定义信息 beanFactory.freezeConfiguration();")]),e._v(" "),t("li",[t("strong",[e._v("beanFactory.preInstantiateSingletons()")]),e._v(": 实例化后剩下的单实例bean")])]),e._v(" "),t("p",[t("mark",[e._v("更精确的是说是根据Bean的定义信息：beanDefinitionNames来实例化、初始化剩余的Bean")])]),e._v(" "),t("h2",{attrs:{id:"_12-finishrefresh"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-finishrefresh"}},[e._v("#")]),e._v(" 12. finishRefresh()")]),e._v(" "),t("blockquote",[t("p",[t("strong",[e._v("完成BeanFactory的初始化创建工作；IOC容器就创建完成")])])]),e._v(" "),t("ol",[t("li",[e._v("clearResourceCaches(); (Spring5.0才有)")]),e._v(" "),t("li",[e._v("initLifecycleProcessor();初始化和生命周期有关的后置处理器；从容器中找是否有lifecycleProcessor的组件【LifecycleProcessor】；如果没有new DefaultLifecycleProcessor();")]),e._v(" "),t("li",[e._v("getLifecycleProcessor().onRefresh();  相当于上面刚注册，下面就调用了")]),e._v(" "),t("li",[e._v("publishEvent(new ContextRefreshedEvent(this));"),t("strong",[e._v("发布容器刷新完成事件")]),e._v("；")]),e._v(" "),t("li",[e._v("liveBeansView.registerApplicationContext(this); 和MBean相关，略")])]),e._v(" "),t("h2",{attrs:{id:"_13-总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-总结"}},[e._v("#")]),e._v(" 13. 总结")]),e._v(" "),t("ol",[t("li",[e._v("Spring容器在启动的时候，先会保存所有注册进来的Bean的定义信息（可以有N种方式）；\n"),t("ul",[t("li",[e._v("xml注册bean；"),t("bean")],1),e._v(" "),t("li",[e._v("注解注册Bean；@Service、@Component、@Bean、xxx")])])]),e._v(" "),t("li",[e._v("Spring容器会合适的时机创建这些Bean\n"),t("ul",[t("li",[e._v("用到这个bean的时候；利用"),t("strong",[e._v("getBean创建bean")]),e._v("；创建好以后保存在容器中；")]),e._v(" "),t("li",[e._v("统一创建剩下所有的bean的时候；finishBeanFactoryInitialization()；")])])]),e._v(" "),t("li",[e._v("后置处理器；BeanPostProcessor\n"),t("ul",[t("li",[e._v("每一个bean创建完成，都会使用各种后置处理器进行处理；来增强bean的功能；")]),e._v(" "),t("li",[e._v("AutowiredAnnotationBeanPostProcessor:处理自动注入")]),e._v(" "),t("li",[e._v("AnnotationAwareAspectJAutoProxyCreator:来做AOP功能；")]),e._v(" "),t("li",[e._v("...")])])]),e._v(" "),t("li",[e._v("事件驱动模型\n"),t("ul",[t("li",[e._v("ApplicationListener；事件监听；")]),e._v(" "),t("li",[e._v("ApplicationEventMulticaster；事件派发：")])])])])])}),[],!1,null,null,null);t.default=o.exports}}]);