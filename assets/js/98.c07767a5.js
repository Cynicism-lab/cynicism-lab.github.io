(window.webpackJsonp=window.webpackJsonp||[]).push([[98],{458:function(t,o,v){"use strict";v.r(o);var _=v(8),r=Object(_.a)({},(function(){var t=this,o=t._self._c;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("h2",{attrs:{id:"_1-三层架构"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1-三层架构"}},[t._v("#")]),t._v(" 1. 三层架构")]),t._v(" "),o("center",[o("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Cynicism-lab/MyResource@gh-pages/image/three.7i6onf5vg0e8.webp",width:"70%"}})]),t._v(" "),o("p",[o("strong",[t._v("① Controller")]),t._v("："),o("code",[t._v("控制层")]),t._v("，接收前端发送的请求，对请求进行处理，并响应数据")]),t._v(" "),o("p",[o("strong",[t._v("② Service")]),t._v("："),o("code",[t._v("业务逻辑层")]),t._v("，处理具体的业务逻辑")]),t._v(" "),o("p",[o("strong",[t._v("③ Dao")]),t._v("："),o("code",[t._v("数据访问层")]),t._v("，负责数据访问操作（增删改查）")]),t._v(" "),o("blockquote",[o("p",[t._v("按照三层架构的思想，对业务逻辑(Service层)进行变更，不会影响到Controller层和Dao层")])]),t._v(" "),o("h2",{attrs:{id:"_2-分层解耦"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-分层解耦"}},[t._v("#")]),t._v(" 2. 分层解耦")]),t._v(" "),o("div",{staticClass:"custom-block tip"},[o("p",{staticClass:"custom-block-title"},[t._v("软件设计原则：高内聚低耦合")]),t._v(" "),o("p",[o("font",{attrs:{color:"#E44E4E"}},[t._v("高内聚")]),t._v('指的是：一个模块中各个元素之间的联系的紧密程度，如果各个元素(语句、程序段)之间的联系程度越高，则内聚性越高，即 "高内聚"。'),o("br"),t._v(" "),o("font",{attrs:{color:"#E44E4E"}},[t._v("低耦合")]),t._v("指的是：软件中各个层、模块之间的依赖关联程序越低越好。"),o("br"),t._v("\n💡为了实现分层解耦，需要借助"),o("strong",[t._v("控制反转")]),t._v("和"),o("strong",[t._v("依赖注入")])],1)]),t._v(" "),o("ul",[o("li",[o("p",[o("strong",[t._v("控制反转：")]),t._v(" Inversion Of Control，简称"),o("strong",[t._v("IOC")]),t._v("。"),o("br"),t._v("\n对象的创建控制权由程序自身转移到外部（容器），这种思想称为控制反转。")]),t._v(" "),o("blockquote",[o("p",[t._v("对象的创建权由程序员主动创建转移到容器(由容器创建、管理对象)。这个容器称为：IOC容器或Spring容器")])])]),t._v(" "),o("li",[o("p",[o("strong",[t._v("依赖注入：")]),t._v(" Dependency Injection，简称"),o("strong",[t._v("DI")]),t._v("。"),o("br"),t._v("\n容器为应用程序提供运行时，所依赖的资源，称之为依赖注入。")]),t._v(" "),o("blockquote",[o("p",[t._v("程序运行时需要某个资源，此时容器就为其提供这个资源。")]),t._v(" "),o("p",[t._v("例：EmpController程序运行时需要EmpService对象，Spring容器就为其提供并注入EmpService对象")])])])]),t._v(" "),o("p",[t._v("   💡"),o("font",{attrs:{color:"#CCA300"}},[t._v("IOC容器中创建、管理的对象，称之为：bean对象")])],1),t._v(" "),o("h2",{attrs:{id:"_3-ioc-di"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_3-ioc-di"}},[t._v("#")]),t._v(" 3. IOC & DI")]),t._v(" "),o("h3",{attrs:{id:"_3-1-解耦概述"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-解耦概述"}},[t._v("#")]),t._v(" 3.1 解耦概述")]),t._v(" "),o("blockquote",[o("p",[o("font",{attrs:{color:"#CCA300"}},[t._v("通过下方两个注解实现解耦过程")])],1)]),t._v(" "),o("ul",[o("li",[o("font",{attrs:{color:"#70F5DA"}},[t._v("@Component")]),t._v(" : 将当前对象交给IOC容器管理,成为IOC容器的bean")],1),t._v(" "),o("li",[o("font",{attrs:{color:"#70F5DA"}},[t._v("@Autowired")]),t._v(" : 运行时,从IOC容器中获取该类型对象,赋值给该变量")],1)]),t._v(" "),o("h3",{attrs:{id:"_3-2-ioc详解"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-ioc详解"}},[t._v("#")]),t._v(" 3.2 IOC详解")]),t._v(" "),o("blockquote",[o("p",[t._v("💡Spring框架为了更好的标识web应用程序开发当中，bean对象到底归属哪一层，提供了@Component的衍生注解："),o("br"),t._v("\n💡注解中可以指定"),o("code",[t._v("value")]),t._v("属性指定生成bean对象的名字，默认为类名首字母小写")])]),t._v(" "),o("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Cynicism-lab/MyResource@gh-pages/image/注解.3y2fm9wbx0qo.webp",width:"70%"}}),t._v(" "),o("div",{staticClass:"custom-block tip"},[o("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),o("ul",[o("li",[t._v("使用四大注解声明的bean，要想生效，还需要被组件扫描注解"),o("font",{attrs:{color:"#70F5DA"}},[t._v("@ComponentScan")]),t._v("扫描")],1),t._v(" "),o("li",[t._v("@ComponentScan注解虽然没有显式配置，但是实际上已经包含在了引导类声明注解 @SpringBootApplication 中，"),o("strong",[t._v("默认扫描的范围是SpringBoot启动类所在包及其子包")]),t._v("。")])])]),t._v(" "),o("h3",{attrs:{id:"_3-3-di详解"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-di详解"}},[t._v("#")]),t._v(" 3.3 DI详解")]),t._v(" "),o("blockquote",[o("p",[o("strong",[t._v("@Autowired注解")]),t._v("，默认是按照"),o("strong",[t._v("类型")]),t._v("进行自动装配的（去IOC容器中找某个类型的对象，然后完成注入操作）,当出现多个相同类型则会报错")])]),t._v(" "),o("p",[o("strong",[o("code",[t._v("解决方案")]),t._v("：")]),o("br"),t._v("\n① 使用"),o("font",{attrs:{color:"#70F5DA"}},[t._v("@Primary")]),t._v("注解：当存在多个相同类型的Bean注入时，在定义类前加上@Primary注解，来确定默认的实现；"),o("br"),t._v("\n② 使用"),o("font",{attrs:{color:"#70F5DA"}},[t._v("@Qualifier")]),t._v("注解：在声明对象时使用，在"),o("code",[t._v("value")]),t._v("属性中，指定注入的bean的名称；"),o("font",{attrs:{color:"#70F5DA"}},[t._v("必须要与@Autowired一起使用")]),o("br"),t._v("\n③ 使用"),o("font",{attrs:{color:"#70F5DA"}},[t._v("@Resource")]),t._v("注解：在声明对象时使用，通过"),o("code",[t._v("name")]),t._v("属性指定要注入的bean的名称，"),o("font",{attrs:{color:"#70F5DA"}},[t._v("可以单独使用")])],1),t._v(" "),o("blockquote",[o("p",[t._v("面试题 ： @Autowird 与 @Resource的区别")]),t._v(" "),o("ul",[o("li",[t._v("@Autowired 是spring框架提供的注解，而@Resource是JDK提供的注解")]),t._v(" "),o("li",[t._v("@Autowired 默认是按照类型注入，而@Resource是按照名称注入")])])])],1)}),[],!1,null,null,null);o.default=r.exports}}]);