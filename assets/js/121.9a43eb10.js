(window.webpackJsonp=window.webpackJsonp||[]).push([[121],{483:function(e,t,a){"use strict";a.r(t);var s=a(8),r=Object(s.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"_1-数据聚合"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-数据聚合"}},[e._v("#")]),e._v(" 1. 数据聚合")]),e._v(" "),t("blockquote",[t("p",[t("a",{attrs:{href:"https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("聚合（"),t("OutboundLink")],1),t("a",{attrs:{href:"https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("aggregations"),t("OutboundLink")],1),t("a",{attrs:{href:"https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("）"),t("OutboundLink")],1),e._v("可以让我们极其方便的实现对数据的统计、分析、运算")])]),e._v(" "),t("p",[e._v("聚合常见的有三类：")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("桶（Bucket）")]),e._v(" 聚合：用来对文档做分组\n"),t("ul",[t("li",[e._v("TermAggregation：按照文档字段值分组，例如按照品牌值分组、按照国家分组")]),e._v(" "),t("li",[e._v("Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组")])])]),e._v(" "),t("li",[t("strong",[e._v("度量（Metric）")]),e._v(" 聚合：用以计算一些值，比如：最大值、最小值、平均值等\n"),t("ul",[t("li",[e._v("Avg：求平均值")]),e._v(" "),t("li",[e._v("Max：求最大值")]),e._v(" "),t("li",[e._v("Min：求最小值")]),e._v(" "),t("li",[e._v("Stats：同时求max、min、avg、sum等")])])]),e._v(" "),t("li",[t("strong",[e._v("管道（pipeline）")]),e._v(" 聚合：其它聚合的结果为基础做聚合")])]),e._v(" "),t("p",[e._v("💡"),t("strong",[e._v("注意：")])]),e._v(" "),t("ul",[t("li",[e._v("默认情况下，Bucket聚合会统计Bucket内的文档数量，记为_count，并且按照_count降序排序")]),e._v(" "),t("li",[e._v("默认情况下，Bucket聚合是对索引库的所有文档做聚合，只要添加query条件即可限定要聚合的文档范围")]),e._v(" "),t("li",[e._v("Metric聚合是在桶Bucket内进行运算")])]),e._v(" "),t("h2",{attrs:{id:"_2-自动补全"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-自动补全"}},[e._v("#")]),e._v(" 2. 自动补全")]),e._v(" "),t("blockquote",[t("p",[e._v("当用户在搜索框输入字符时，我们应该提示出与该字符有关的搜索项;因为需要根据拼音字母来推断，因此要用到拼音分词功能")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Cynicism-lab/MyResource@gh-pages/image/image-20210723204936367.58jqbni98hds.webp",alt:""}})]),e._v(" "),t("h3",{attrs:{id:"_2-1-拼音分词器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-拼音分词器"}},[e._v("#")]),e._v(" 2.1 拼音分词器")]),e._v(" "),t("blockquote",[t("p",[e._v("要实现根据字母做补全，就必须对文档按照拼音分词。在GitHub上恰好有elasticsearch的拼音分词插件。地址：https://github.com/medcl/elasticsearch-analysis-pinyin")])]),e._v(" "),t("h3",{attrs:{id:"_2-2-自定义分词器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-自定义分词器"}},[e._v("#")]),e._v(" 2.2 自定义分词器")]),e._v(" "),t("blockquote",[t("p",[e._v("默认的拼音分词器会将每个汉字单独分为拼音，而我们希望的是每个词条形成一组拼音，需要对拼音分词器做个性化定制，形成自定义分词器。")])]),e._v(" "),t("p",[e._v("elasticsearch中分词器（analyzer）的组成包含三部分：")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("character filters")]),e._v("：在tokenizer之前对文本进行处理。例如删除字符、替换字符")]),e._v(" "),t("li",[t("code",[e._v("tokenizer")]),e._v("：将文本按照一定的规则切割成词条（term）。例如keyword，就是不分词；还有ik_smart")]),e._v(" "),t("li",[t("code",[e._v("tokenizer filter")]),e._v("：将tokenizer输出的词条做进一步处理。例如大小写转换、同义词处理、拼音处理等")])]),e._v(" "),t("p",[t("mark",[e._v("为了避免搜索到同音字,拼音分词器适合在创建倒排索引时使用，但搜索时不要使用拼音分词器")])]),e._v(" "),t("h3",{attrs:{id:"_2-3-自动补全查询"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-自动补全查询"}},[e._v("#")]),e._v(" 2.3 自动补全查询")]),e._v(" "),t("blockquote",[t("p",[e._v("elasticsearch提供了"),t("a",{attrs:{href:"https://www.elastic.co/guide/en/elasticsearch/reference/7.6/search-suggesters.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Completion Suggester"),t("OutboundLink")],1),e._v("查询来实现自动补全功能。这个查询会匹配以用户输入内容开头的词条并返回。")])]),e._v(" "),t("p",[e._v("为了提高补全查询的效率，对于文档中字段的类型有一些约束：")]),e._v(" "),t("ul",[t("li",[e._v("参与补全查询的字段必须是completion类型。")]),e._v(" "),t("li",[e._v("字段的内容一般是用来补全的多个词条形成的数组。")])]),e._v(" "),t("h2",{attrs:{id:"_3-数据同步"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-数据同步"}},[e._v("#")]),e._v(" 3. 数据同步")]),e._v(" "),t("blockquote",[t("p",[e._v("elasticsearch中的数据来自于mysql数据库，因此mysql数据发生改变时，elasticsearch也必须跟着改变，这个就是elasticsearch与mysql之间的"),t("strong",[e._v("数据同步")]),e._v(" "),t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Cynicism-lab/MyResource@gh-pages/image/image-20210723214758392.32wfptxx2328.png",alt:""}})])]),e._v(" "),t("h3",{attrs:{id:"_3-1-数据同步方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-数据同步方案"}},[e._v("#")]),e._v(" 3.1 数据同步方案")]),e._v(" "),t("p",[t("strong",[e._v("① 同步调用")]),t("br"),e._v(" "),t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Cynicism-lab/MyResource@gh-pages/image/image-20210723214931869.10xrtsy2jvnk.png",alt:""}})]),e._v(" "),t("ul",[t("li",[e._v("优点：实现简单，粗暴")]),e._v(" "),t("li",[e._v("缺点：业务耦合度高")])]),e._v(" "),t("p",[t("strong",[e._v("② 异步通知")]),e._v(" "),t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Cynicism-lab/MyResource@gh-pages/image/image-20210723215140735.21ug2d5mzy0w.png",alt:""}})]),e._v(" "),t("ul",[t("li",[e._v("优点：低耦合，实现难度一般")]),e._v(" "),t("li",[e._v("缺点：依赖mq的可靠性")])]),e._v(" "),t("p",[t("strong",[e._v("③ 监听binlog")]),e._v(" "),t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Cynicism-lab/MyResource@gh-pages/image/image-20210723215518541.2l19pk79h9ts.png",alt:""}})]),e._v(" "),t("ul",[t("li",[e._v("优点：完全解除服务间耦合")]),e._v(" "),t("li",[e._v("缺点：开启binlog增加数据库负担、实现复杂度高")])]),e._v(" "),t("h2",{attrs:{id:"_4-集群"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-集群"}},[e._v("#")]),e._v(" 4. 集群")]),e._v(" "),t("h3",{attrs:{id:"_4-1-基础概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-基础概念"}},[e._v("#")]),e._v(" 4.1 基础概念")]),e._v(" "),t("blockquote",[t("p",[e._v("单机的elasticsearch做数据存储，必然面临两个问题：海量数据存储问题、单点故障问题。")]),e._v(" "),t("ul",[t("li",[e._v("海量数据存储问题：将索引库从逻辑上拆分为N个分片（shard），存储到多个节点")]),e._v(" "),t("li",[e._v("单点故障问题：将分片数据在不同节点备份（replica ）")])])]),e._v(" "),t("p",[t("strong",[e._v("ES集群相关概念")]),e._v(":")]),e._v(" "),t("ul",[t("li",[e._v("集群（cluster）：一组拥有共同的 cluster name 的 节点。")]),e._v(" "),t("li",[t("font",{attrs:{color:"red"}},[e._v("节点（node)")]),e._v("   ：集群中的一个 Elasticearch 实例")],1),e._v(" "),t("li",[t("font",{attrs:{color:"red"}},[e._v("分片（shard）")]),e._v("：索引可以被拆分为不同的部分进行存储，称为分片。在集群环境下，一个索引的不同分片可以拆分到不同的节点中\n"),t("strong",[e._v("解决问题：数据量太大，单点存储量有限的问题。")])],1),e._v(" "),t("li",[e._v("主分片（Primary shard）：相对于副本分片的定义。")]),e._v(" "),t("li",[e._v("副本分片（Replica shard）每个主分片可以有一个或者多个副本，数据和主分片一样。\n"),t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Cynicism-lab/MyResource@gh-pages/image/image-20200104124551912.vbx6myhqvkw.webp",alt:""}})])]),e._v(" "),t("h3",{attrs:{id:"_4-2-集群脑裂问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-集群脑裂问题"}},[e._v("#")]),e._v(" 4.2 集群脑裂问题")]),e._v(" "),t("h4",{attrs:{id:"_4-2-1-集群职责划分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-1-集群职责划分"}},[e._v("#")]),e._v(" 4.2.1 集群职责划分")]),e._v(" "),t("p",[e._v("🏷️ elasticsearch中集群节点有不同的职责划分：\n"),t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Cynicism-lab/MyResource@gh-pages/image/image-20210723223008967.4ci10wlrau80.webp",alt:""}})]),e._v(" "),t("blockquote",[t("p",[e._v("默认情况下，集群中的任何一个节点都同时具备上述四种角色。\n但是真实的集群一定要将集群职责分离：")])]),e._v(" "),t("ul",[t("li",[e._v("master节点：对CPU要求高，但是内存要求低")]),e._v(" "),t("li",[e._v("data节点：对CPU和内存要求都高")]),e._v(" "),t("li",[e._v("coordinating节点：对网络带宽、CPU要求高")])]),e._v(" "),t("blockquote",[t("p",[e._v("职责分离可以让我们根据不同节点的需求分配不同的硬件去部署。而且避免业务之间的互相干扰。")])]),e._v(" "),t("p",[e._v("一个典型的es集群职责划分如图：\n"),t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Cynicism-lab/MyResource@gh-pages/image/image-20210723223629142.6t1b3jp52d1c.webp",alt:""}})]),e._v(" "),t("h4",{attrs:{id:"_4-2-2-脑裂问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-2-脑裂问题"}},[e._v("#")]),e._v(" 4.2.2 脑裂问题")]),e._v(" "),t("blockquote",[t("p",[e._v("脑裂是因为集群中的节点失联导致的。")])]),e._v(" "),t("ul",[t("li",[t("p",[e._v("例如一个集群中，主节点与其它节点失联：\n"),t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Cynicism-lab/MyResource@gh-pages/image/image-20210723223804995.69k8sz8yndz4.webp",alt:""}})])]),e._v(" "),t("li",[t("p",[e._v("此时，node2和node3认为node1宕机，就会重新选主：\n"),t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Cynicism-lab/MyResource@gh-pages/image/image-20210723223845754.9fwx0ibgvvg.webp",alt:""}})])]),e._v(" "),t("li",[t("p",[e._v("当node3当选后，集群继续对外提供服务，node2和node3自成集群，node1自成集群，两个集群"),t("strong",[e._v("数据不同步，出现数据差异")]),e._v("。")])]),e._v(" "),t("li",[t("p",[e._v("当网络恢复后，因为集群中有两个master节点，集群状态的不一致，出现脑裂的情况\n"),t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Cynicism-lab/MyResource@gh-pages/image/image-20210723224000555.6wzak88vrcsg.webp",alt:""}})])])]),e._v(" "),t("blockquote",[t("p",[t("strong",[e._v("解决方案")]),e._v("：\n要求选票超过 ( eligible节点数量 + 1 ）/ 2 才能当选为主，因此eligible节点数量最好是奇数。对应配置项是discovery.zen.minimum_master_nodes，在es7.0以后，已经成为默认配置，因此一般不会发生脑裂问题")])]),e._v(" "),t("p",[e._v("例如：3个节点形成的集群，选票必须超过 （3 + 1） / 2 ，也就是2票。node3得到node2和node3的选票，当选为主。node1只有自己1票，没有当选。集群中依然只有1个主节点，没有出现脑裂。")]),e._v(" "),t("h3",{attrs:{id:"_4-3-集群分布式存储"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-集群分布式存储"}},[e._v("#")]),e._v(" 4.3 集群分布式存储")]),e._v(" "),t("blockquote",[t("p",[e._v("当新增文档时，应该保存到不同分片，保证数据均衡，那么coordinating node如何确定数据该存储到哪个分片呢？")])]),e._v(" "),t("p",[e._v("🏷️ elasticsearch会通过"),t("strong",[e._v("hash算法")]),e._v("来计算文档应该存储到哪个分片：\n"),t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Cynicism-lab/MyResource@gh-pages/image/image-20210723224354904.1ersxw636d6o.webp",alt:""}})]),e._v(" "),t("ul",[t("li",[e._v("_routing默认是文档的id")]),e._v(" "),t("li",[e._v("算法与分片数量有关，因此索引库一旦创建，分片数量不能修改！")])]),e._v(" "),t("p",[t("strong",[e._v("新增文档的流程如下：")]),e._v(" "),t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Cynicism-lab/MyResource@gh-pages/image/image-20210723225436084.38f8h3wc8s3k.webp",alt:""}})]),e._v(" "),t("h3",{attrs:{id:"_4-4-集群分布式查询"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-集群分布式查询"}},[e._v("#")]),e._v(" 4.4 集群分布式查询")]),e._v(" "),t("p",[e._v("elasticsearch的查询分成两个阶段：")]),e._v(" "),t("ul",[t("li",[e._v("scatter phase：分散阶段，coordinating node会把请求分发到每一个分片")]),e._v(" "),t("li",[e._v("gather phase：聚集阶段，coordinating node汇总data node的搜索结果，并处理为最终结果集返回给用户")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Cynicism-lab/MyResource@gh-pages/image/image-20210723225809848.4679kknsu8ow.webp",alt:""}})]),e._v(" "),t("h3",{attrs:{id:"_4-5-集群故障转移"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-集群故障转移"}},[e._v("#")]),e._v(" 4.5 集群故障转移")]),e._v(" "),t("blockquote",[t("p",[e._v("集群的master节点会监控集群中的节点状态，如果发现有节点宕机，会立即将宕机节点的分片数据迁移到其它节点，确保数据安全，这个叫做故障转移。")])]),e._v(" "),t("ul",[t("li",[e._v("例如一个集群结构如图：\n"),t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Cynicism-lab/MyResource@gh-pages/image/image-20210723225945963.1446rv94qluo.webp",alt:""}})]),e._v(" "),t("li",[e._v("突然，node1发生了故障：\n"),t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Cynicism-lab/MyResource@gh-pages/image/image-20210723230020574.4so5bdnyr0g0.webp",alt:""}})]),e._v(" "),t("li",[e._v("宕机后的第一件事，需要重新选主，例如选中了node2：\n"),t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Cynicism-lab/MyResource@gh-pages/image/image-20210723230055974.5pegsgpuwveo.webp",alt:""}})]),e._v(" "),t("li",[e._v("node2成为主节点后，会检测集群监控状态，发现：shard-1、shard-0没有副本节点。因此需要将node1上的数据迁移到node2、node3：\n"),t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Cynicism-lab/MyResource@gh-pages/image/image-20210723230216642.3em98a92qcsg.webp",alt:""}})])])])}),[],!1,null,null,null);t.default=r.exports}}]);