---
title: 微服务保护
decription: 
date: 2023-06-30
tags: 
  - springcloud
categories: 
  - 《SpringCloud》笔记
permalink: /pages/1f196bah/
author: 
  name: cynicism
  link: https://github.com/cynicism-lab
---
## 1. 初识Sentinel
### 1.1 雪崩问题及解决方案
#### 1.1.1 雪崩问题
>微服务之间相互调用，因为调用链中的一个服务故障，引起整个链路都无法访问的情况

- 微服务中，服务间调用关系错综复杂，一个微服务往往依赖于多个其它微服务
![](https://cdn.staticaly.com/gh/Cynicism-lab/MyResource@gh-pages/image/1533829198240.2jd3w915rkow.webp)
- 如果服务提供者I发生了故障，当前的应用的部分业务因为依赖于服务I，因此也会被阻塞。此时，其它不依赖于服务I的业务似乎不受影响
- 但是，依赖服务I的业务请求被阻塞，用户不会得到响应，则tomcat的这个线程不会释放，于是越来越多的用户请求到来，越来越多的线程会阻塞
- 服务器支持的线程和并发数有限，请求一直阻塞，会导致服务器资源耗尽，从而导致所有其它服务都不可用，那么当前服务也就不可用了。
![](https://cdn.staticaly.com/gh/Cynicism-lab/MyResource@gh-pages/image/image-20210715172710340.5vaczsbg3xj4.webp)
那么，依赖于当前服务的其它服务随着时间的推移，最终也都会变的不可用，形成级联失败，雪崩就发生了

#### 1.1.2 解决方案
解决雪崩问题的常见方式有四种：
- **超时处理**：设定超时时间，请求超过一定时间没有响应就返回错误信息，不会无休止等待
- **仓壁模式**: 限定每个业务能使用的线程数，避免耗尽整个tomcat的资源，因此也叫线程隔离
- **断路器模式**：由**断路器**统计业务执行的异常比例，如果超出阈值则会**熔断**该业务，拦截访问该业务的一切请求
- **流量控制**：限制业务访问的QPS，避免服务因流量的突增而故障

### 1.2 服务保护技术对比
|                | **Sentinel**                                   | **Hystrix**                   |
| -------------- | ---------------------------------------------- | ----------------------------- |
| **隔离策略**       | 信号量隔离                                     | 线程池隔离/信号量隔离         |
| **熔断降级策略**   | 基于慢调用比例或异常比例                       | 基于失败比率                  |
| 实时指标实现   | 滑动窗口                                       | 滑动窗口（基于 RxJava）       |
| 规则配置       | 支持多种数据源                                 | 支持多种数据源                |
| 扩展性         | 多个扩展点                                     | 插件的形式                    |
| 基于注解的支持 | 支持                                           | 支持                          |
| **限流**           | 基于 QPS，支持基于调用关系的限流               | 有限的支持                    |
| **流量整形**       | 支持慢启动、匀速排队模式                       | 不支持                        |
| 系统自适应保护 | 支持                                           | 不支持                        |
| **控制台**         | 开箱即用，可配置规则、查看秒级监控、机器发现等 | 不完善                        |
| 常见框架的适配 | Servlet、Spring Cloud、Dubbo、gRPC  等         | Servlet、Spring Cloud Netflix |


## 2. 流量控制
>雪崩问题虽然有四种方案，但是限流是避免服务因突发的流量而发生故障，是对微服务雪崩问题的预防。我们先学习这种模式。
### 2.1 簇点链路
>当请求进入微服务时，首先会访问DispatcherServlet，然后进入Controller、Service、Mapper，这样的一个调用链就叫做**簇点链路**。簇点链路中被监控的每一个接口就是一个**资源**。

默认情况下sentinel会监控SpringMVC的每一个端点（Endpoint，也就是controller中的方法），因此SpringMVC的每一个端点（Endpoint）就是调用链路中的一个资源。

### 2.2.流控模式
在添加限流规则时，点击高级选项，可以选择三种**流控模式**：
- **直接**：统计当前资源的请求，触发阈值时对当前资源直接限流，也是默认的模式
- **关联**：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流
- **链路**：统计从指定链路访问到本资源的请求，触发阈值时，对指定链路限流

### 2.3 流控效果
流控效果是指请求达到流控阈值时应该采取的措施，包括三种：
- **快速失败**：达到阈值后，新的请求会被立即拒绝并抛出FlowException异常。是默认的处理方式。
- **warm up**：预热模式，对超出阈值的请求同样是拒绝并抛出异常。但这种模式阈值会动态变化，从一个较小值逐渐增加到最大阈值。
- **排队等待**：让所有的请求按照先后次序排队执行，两个请求的间隔不能小于指定时长

### 2.4 热点参数限流
>之前的限流是统计访问某个资源的所有请求，判断是否超过QPS阈值。而热点参数限流是**分别统计参数值相同的请求**，判断是否超过QPS阈值

- 全局参数限流: 访问/goods/{id}的请求中，id参数值会有变化，热点参数限流会根据参数值分别统计QPS，统计结果

>刚才的配置中，对查询商品这个接口的所有商品一视同仁，QPS都限定为5.而在实际开发中，可能部分商品是热点商品，例如秒杀商品，我们希望这部分商品的QPS限制与其它商品不一样，高一些。那就需要配置热点参数限流的高级选项了：
- 热点参数限流


**注意事项**：热点参数限流对默认的SpringMVC资源无效，需要利用@SentinelResource注解标记资源

## 3. 隔离和降级
>限流是一种预防措施，虽然限流可以尽量避免因高并发而引起的服务故障，但服务还会因为其它原因而故障。而要将这些故障控制在一定范围，避免雪崩，就要靠**线程隔离**（舱壁模式）和**熔断降级**手段了

<mark>SpringCloud中，微服务调用都是通过Feign来实现的，因此做客户端保护必须整合Feign和Sentinel</mark>
💡业务失败后，不能直接报错，而应该返回用户一个友好提示或者默认结果，这个就是失败降级逻辑
给FeignClient编写失败后的降级逻辑
①方式一：FallbackClass，无法对远程调用的异常做处理
②方式二： **FallbackFactory** ，可以对远程调用的异常做处理，我们选择这种

### 3.1 线程隔离（舱壁模式）
线程隔离有两种方式实现：
**线程池隔离**：给每个服务调用业务分配一个线程池，利用线程池本身实现隔离效果
**信号量隔离**：不创建线程池，而是计数器模式，记录业务使用的线程数量，达到信号量上限时，禁止新的请求(Sentinel默认采用)

![](https://cdn.staticaly.com/gh/Cynicism-lab/MyResource@gh-pages/image/image-20210716123240518.5pqvf8t59d34.webp)

### 3.2 熔断降级
>熔断降级是解决雪崩问题的重要手段。其思路是由**断路器**统计服务调用的异常比例、慢请求比例，如果超出阈值则会**熔断**该服务。即拦截访问该服务的一切请求；而当服务恢复时，断路器会放行访问该服务的请求

断路器控制熔断和放行是通过状态机来完成的：
![](https://cdn.staticaly.com/gh/Cynicism-lab/MyResource@gh-pages/image/image-20210716130958518.5r05zjo28kqo.webp)

状态机包括三个状态：
- closed：关闭状态，断路器放行所有请求，并开始统计异常比例、慢请求比例。超过阈值则切换到open状态
- open：打开状态，服务调用被**熔断**，访问被熔断服务的请求会被拒绝，快速失败，直接走降级逻辑。Open状态5秒后会进入half-open状态
- half-open：半开状态，放行一次请求，根据执行结果来判断接下来的操作。
  - 请求成功：则切换到closed状态
  - 请求失败：则切换到open状态

断路器熔断策略有三种:
- **慢调用**：业务的响应时长（RT）大于指定时长的请求认定为慢调用请求。在指定时间内，如果请求数量超过设定的最小数量，慢调用比例大于设定的阈值，则触发熔断
- **异常比例或异常数**：统计指定时间内的调用，如果调用次数超过指定请求数，并且出现异常的比例达到设定的比例阈值（或超过指定异常数），则触发熔断

## 4. 授权规则
>授权规则可以对请求方来源做判断和控制
### 4.1 基本规则
授权规则可以对调用方的来源做控制，有白名单和黑名单两种方式。
- 白名单：来源（origin）在白名单内的调用者允许访问
- 黑名单：来源（origin）在黑名单内的调用者不允许访问

### 4.2 自定义异常结果
>默认情况下，发生限流、降级、授权拦截时，都会抛出异常到调用方。异常结果都是flow limmiting（限流）。这样不够友好，无法得知是限流还是降级还是授权拦截

如果要自定义异常时的返回结果，需要实现BlockExceptionHandler接口

这里的BlockException包含多个不同的子类：
| **异常**             | **说明**           |
| -------------------- | ------------------ |
| FlowException        | 限流异常           |
| ParamFlowException   | 热点参数限流的异常 |
| DegradeException     | 降级异常           |
| AuthorityException   | 授权规则异常       |
| SystemBlockException | 系统规则异常       |

## 5. 规则持久化
>sentinel的所有规则都是**内存存储**，重启后所有规则都会丢失。在生产环境下，我们必须确保这些规则的持久化，避免丢失

规则是否能持久化，取决于规则管理模式，sentinel支持三种规则管理模式：
- 原始模式：Sentinel的默认模式，将规则保存在内存，重启服务会丢失。
- pull模式: 控制台将配置的规则推送到Sentinel客户端，而客户端会将配置规则保存在本地文件或数据库中。以后会定时去本地文件或数据库中查询，更新本地规则
- **push模式**(推荐): 控制台将配置规则推送到远程配置中心，例如Nacos。Sentinel客户端监听Nacos，获取配置变更的推送消息，完成本地配置更新


