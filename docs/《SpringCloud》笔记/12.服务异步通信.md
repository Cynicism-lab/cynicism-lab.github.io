---
title: 服务异步通信
decription: 
date: 2023-07-05
tags: 
  - springcloud
categories: 
  - 《SpringCloud》笔记
permalink: /pages/1f196bam/
author: 
  name: cynicism
  link: https://github.com/cynicism-lab
---
>消息队列在使用过程中，面临着很多实际问题需要思考：

![](https://cdn.jsdelivr.net/gh/Cynicism-lab/MyResource@gh-pages/image/image-20210718155003157.61p28hvr7uv4.webp)
## 1. 消息可靠性
消息从发送，到消费者接收，会经理多个过程, 其中的每一步都可能导致消息丢失，常见的丢失原因包括：
- 发送时丢失：
  - 生产者发送的消息未送达exchange
  - 消息到达exchange后未到达queue
- MQ宕机，queue将消息丢失
- consumer接收到消息后未消费就宕机

针对这些问题，RabbitMQ分别给出了解决方案：
- 生产者确认机制
- mq持久化
- 消费者确认机制
- 失败重试机制

### 1.1 生产者消息确认
RabbitMQ提供了**publisher confirm**机制来避免消息发送到MQ过程中丢失。这种机制必须给每个消息指定一个唯一ID。消息发送到MQ以后，会返回一个结果给发送者，表示消息是否处理成功。

返回结果有两种方式：
- publisher-confirm，发送者确认
  - 消息成功投递到交换机，返回ack
  - 消息未投递到交换机，返回nack
- publisher-return，发送者回执
  - 消息投递到交换机了，但是没有路由到队列。返回ACK，及路由失败原因。

![](https://cdn.jsdelivr.net/gh/Cynicism-lab/MyResource@gh-pages/image/image-20210718161707992.1cku379oy4hs.webp)

### 1.2 消息持久化
>生产者确认可以确保消息投递到RabbitMQ的队列中，但是消息发送到RabbitMQ以后，如果突然宕机，也可能导致消息丢失。

要想确保消息在RabbitMQ中安全保存，必须开启消息持久化机制。
- 交换机持久化
- 队列持久化
- 消息持久化
  
<mark>默认情况下，由SpringAMQP声明的交换机、队列、消息都是持久化的</mark>

### 1.3 消费者消息确认
RabbitMQ是**阅后即焚**机制，RabbitMQ确认消息被消费者消费后会立刻删除。

而RabbitMQ是通过**消费者回执**来确认消费者是否成功处理消息的：消费者获取消息后，应该向RabbitMQ发送`ACK`回执，表明自己已经处理消息

SpringAMQP则允许配置三种确认模式：
- **manual**：手动ack，需要在业务代码结束后，调用api发送ack。
- **auto**：自动ack，由spring监测listener代码是否出现异常，没有异常则返回ack；抛出异常则返回nack
- **none**：关闭ack，MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除

### 1.4 消费失败重试机制
>当消费者出现异常后，消息会不断requeue（重入队）到队列，再重新发送给消费者，然后再次异常，再次requeue，无限循环，导致mq的消息处理飙升，带来不必要的压力

#### 1.4.1 本地重试
利用Spring的retry机制，在消费者出现异常时利用本地重试，而不是无限制的requeue到mq队列
- 开启本地重试时，消息处理过程中抛出异常，不会requeue到队列，而是在消费者本地重试
- 重试达到最大次数后，Spring会返回ack，消息会被丢弃

#### 1.4.2 失败策略
在本地重试中，达到最大重试次数后，消息会被丢弃，这是由Spring内部机制决定的。

在开启重试模式后，重试次数耗尽，如果消息依然失败，则需要有MessageRecovery接口来处理，它包含三种不同的实现：
- `RejectAndDontRequeueRecoverer`：重试耗尽后，直接reject，丢弃消息。**默认**就是这种方式
- `ImmediateRequeueMessageRecoverer`：重试耗尽后，返回nack，消息重新入队
- `RepublishMessageRecoverer`：重试耗尽后，将失败消息投递到指定的交换机

>比较优雅的一种处理方案是RepublishMessageRecoverer，失败后将消息投递到一个指定的，专门存放异常消息的队列，后续由人工集中处理。

## 2. 死信交换机
### 2.1 初识死信交换机
当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：
- 消费者使用basic.reject或 basic.nack声明消费失败，并且消息的requeue参数设置为false
- 消息是一个过期消息，超时无人消费
- 要投递的队列消息满了，无法投递

如果这个包含死信的队列配置了`dead-letter-exchange`属性，指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机称为**死信交换机**（Dead Letter Exchange，检查DLX）。

### 2.2 TTL
一个队列中的消息如果超时未消费，则会变为死信，超时分为两种情况：
- 消息所在的队列设置了超时时间
- 消息本身设置了超时时间

### 2.3 延迟队列
>利用TTL结合死信交换机，我们实现了消息发出后，消费者延迟收到消息的效果。这种消息模式就称为延迟队列（Delay Queue）模式。

![](https://cdn.jsdelivr.net/gh/Cynicism-lab/MyResource@gh-pages/image/image-20210718182643311.7ii7dtdc13wg.webp)
延迟队列的使用场景包括：
- 延迟发送短信
- 用户下单，如果用户在15 分钟内未支付，则自动取消
- 预约工作会议，20分钟后自动通知所有参会人员

## 3. 惰性队列
### 3.1 消息堆积问题
:::tip 消息堆积
当生产者发送消息的速度超过了消费者处理消息的速度，就会导致队列中的消息堆积，直到队列存储消息达到上限。之后发送的消息就会成为死信，可能会被丢弃
:::
解决消息堆积有两种思路：
- 增加更多消费者，提高消费速度。也就是我们之前说的work queue模式
- 扩大队列容积，提高堆积上限

>要提升队列容积，把消息保存在内存中显然是不行的。

### 3.2 惰性队列
>从RabbitMQ的3.6.0版本开始，就增加了Lazy Queues的概念，也就是惰性队列。

**惰性队列的特征如下：**
- 接收到消息后直接存入磁盘而非内存
- 消费者要消费消息时才会从磁盘中读取并加载到内存
- 支持数百万条的消息存储

**惰性队列的优点有哪些？**
- 基于磁盘存储，消息上限高
- 没有间歇性的page-out，性能比较稳定

**惰性队列的缺点有哪些？**
- 基于磁盘存储，消息时效性会降低
- 性能受限于磁盘的IO

## 4. MQ集群
### 4.1 集群分类
>RabbitMQ的是基于Erlang语言编写，而Erlang又是一个面向并发的语言，天然支持集群模式。

RabbitMQ的集群有两种模式：
- **普通集群**：是一种分布式集群，将队列分散到集群的各个节点，从而提高整个集群的并发能力。
- **镜像集群**：是一种主从集群，普通集群的基础上，添加了主从备份功能，提高集群的数据可用性。

镜像集群虽然支持主从，但主从同步并不是强一致的，某些情况下可能有数据丢失的风险。因此在RabbitMQ的3.8版本以后，推出了新的功能：**仲裁队列**来代替镜像集群，底层采用Raft协议确保主从的数据一致性

### 4.2.普通集群
普通集群，或者叫标准集群（classic cluster），具备下列特征：
- 会在集群的各个节点间共享部分数据，包括：交换机、队列元信息。**不包含队列中的消息。**
- 当访问集群某节点时，如果队列不在该节点，会从数据所在节点传递到当前节点并返回
- 队列所在节点宕机，队列中的消息就会丢失

![](https://cdn.jsdelivr.net/gh/Cynicism-lab/MyResource@gh-pages/image/image-20210718220843323.7aeulr13gr9c.webp)

### 4.3 镜像集群
镜像集群：本质是主从模式，具备下面的特征：
- 交换机、队列、队列中的消息会在各个mq的镜像节点之间**同步备份**。
- 创建队列的节点被称为该队列的**主节点，**备份到的其它节点叫做该队列的**镜像**节点。
- 一个队列的主节点可能是另一个队列的镜像节点
- 所有操作都是主节点完成，然后同步给镜像节点
- 主宕机后，镜像节点会替代成新的主节点

![](https://cdn.jsdelivr.net/gh/Cynicism-lab/MyResource@gh-pages/image/image-20210718221039542.678g9fgir3eo.webp)

### 4.4.仲裁队列
仲裁队列：仲裁队列是3.8版本以后才有的新功能，用来替代镜像队列，具备下列特征：
- 与镜像队列一样，都是主从模式，支持主从数据同步
- 使用非常简单，没有复杂的配置
- 主从同步基于Raft协议，强一致






