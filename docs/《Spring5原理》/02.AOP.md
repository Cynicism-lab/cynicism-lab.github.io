---
title: AOP
date: 2023-08-05 20:45:35
permalink: /pages/f344d070a1033aeg
author: cynicism
categories:
  - 《Spring5原理》
tags:
  - spring
---
## 1. AOP实现补充
>AOP 底层实现方式之一是**代理**，由代理结合通知和目标，提供增强功能

除此以外，aspectj 提供了两种另外的 AOP 底层实现：

* 第一种是通过 ajc 编译器在**编译** class 类文件时，就把通知的增强功能，织入到目标类(target目录)的字节码中
>可以对构造方法、静态方法等实现增强

* 第二种是通过 agent 在**加载**目标类时，修改目标类的字节码，织入增强功能
>作为对比，之前学习的代理是**运行**时生成新的字节码

## 2. AOP 实现之 proxy
- jdk 动态代理
>jdk 动态代理要求目标**必须实现接口**，生成的代理类实现相同接口，因此代理与目标之间是**平级兄弟关系**
>回调接口**InvocationHandler()**实现代理增强

- cglib 代理
>cglib 不要求目标实现接口，**它生成的代理类是目标的子类**，因此代理与目标之间是**子父关系**
>限制⛔：根据上述分析 final 类无法被 cglib 增强
>回调的接口换了一下，InvocationHandler 改成了 **MethodInterceptor**

🔎**对比** :
* method.invoke 是反射调用，必须调用到足够次数才会进行优化(**jdk动态代理中只有这种)**
* methodProxy.invoke 是不反射调用，它会正常（间接）调用**目标对象**的方法（**Spring 采用**）
* methodProxy.invokeSuper 也是不反射调用，它会正常（间接）调用**代理对象**的方法，可以省略目标对象

## 3. cglib 避免反射调用
1. 当调用 MethodProxy 的 invoke 或 invokeSuper 方法时, 会动态生成两个类
   * ProxyFastClass 配合代理对象一起使用, 避免反射
   * TargetFastClass 配合目标对象一起使用, 避免反射 (**Spring 用的这种**)
2. TargetFastClass 记录了 Target 中方法与编号的对应关系
   - save(long) 编号 2
   - save(int) 编号 1
   - save() 编号 0
   - 首先根据方法名和参数个数、类型, 用 switch 和 if 找到这些方法编号
   - 然后再根据编号去调用目标方法, 又用了一大堆 switch 和 if, 但**避免了反射**
3. ProxyFastClass 记录了 Proxy 中方法与编号的对应关系，不过 Proxy 额外提供了下面几个方法
   * saveSuper(long) 编号 2，不增强，仅是调用 super.save(long)
   * saveSuper(int) 编号 1，不增强, 仅是调用 super.save(int)
   * saveSuper() 编号 0，不增强, 仅是调用 super.save()
   * 查找方式与 TargetFastClass 类似
4. 为什么有这么麻烦的一套东西呢？
   * **避免反射, 提高性能**, 代价是一个代理类配两个 FastClass 类, 代理类中还得增加仅调用 super 的一堆方法
   * 用编号处理方法对应关系比较**省内存**, 另外, 最初获得方法顺序是不确定的, 这个过程没法固定死


## 4. jdk 和 cglib 在 Spring 中的统一
**ProxyFactory 用来创建代理**
   * 如果目标类实现了接口，且 **proxyTargetClass** = false，使用 JdkDynamicAopProxy
   * 如果没有指定接口，或者 proxyTargetClass = true，使用 ObjenesisCglibAopProxy
     * 例外：如果目标是接口类型或已经是 Jdk 代理，使用 JdkDynamicAopProxy

## 5. 从 @Aspect 到 Advisor
1. AnnotationAwareAspectJAutoProxyCreator 的作用
   * 将高级 @Aspect 切面统一为低级 Advisor 切面
   * 在合适的时机创建代理
2. findEligibleAdvisors 找到有【资格】的 Advisors
   * 有【资格】的 Advisor 一部分是低级的, 可以由自己编写, 如本例 A17 中的 advisor3
   * 有【资格】的 Advisor 另一部分是高级的, 由解析 @Aspect 后获得
3. wrapIfNecessary
   * 它内部调用 findEligibleAdvisors, 只要返回集合不空, 则表示需要创建代理
   * **它的调用时机通常在原始对象初始化后执行, 但碰到循环依赖会提前至依赖注入之前执行**

## 6. 静态通知调用
>所有的通知类型都会转换为环绕通知 **MethodInterceptor**

**代理方法执行时会做如下工作** 
1. 通过 proxyFactory 的 getInterceptorsAndDynamicInterceptionAdvice() 将其他通知统一转换为 MethodInterceptor 环绕通知
      - MethodBeforeAdviceAdapter 将 @Before AspectJMethodBeforeAdvice 适配为 MethodBeforeAdviceInterceptor
      - AfterReturningAdviceAdapter 将 @AfterReturning AspectJAfterReturningAdvice 适配为 AfterReturningAdviceInterceptor
      - 这体现的是**适配器设计模式**
2. 所谓静态通知，体现在上面方法的 Interceptors 部分，这些通知调用时无需再次检查切点，直接调用即可(**有无参数**)
3. 结合目标与环绕通知链，创建 MethodInvocation 对象，通过它完成整个调用

![](https://cdn.jsdelivr.net/gh/Cynicism-lab/MyResource@gh-pages/image/QQ截图20230805204629.6mnao5cvop34.webp)

**代理对象调用流程如下（以 JDK 动态代理实现为例）**

* 从 ProxyFactory 获得 Target 和环绕通知链，根据他俩创建 MethodInvocation（环绕通知），简称 mi
* 首次执行 mi.proceed() 发现有下一个环绕通知，调用它的 invoke(mi)
* 进入环绕通知1，执行前增强，再次调用 mi.proceed() 发现有下一个环绕通知，调用它的 invoke(mi)
* 进入环绕通知2，执行前增强，调用 mi.proceed() 发现没有环绕通知，调用 mi.invokeJoinPoint() 执行目标方法
* 目标方法执行结束，将结果返回给环绕通知2，执行环绕通知2 的后增强
* 环绕通知2继续将结果返回给环绕通知1，执行环绕通知1 的后增强
* 环绕通知1返回最终的结果

## 7. 动态通知调用
1. 通过 proxyFactory 的 getInterceptorsAndDynamicInterceptionAdvice() 将其他通知统一转换为 MethodInterceptor 环绕通知
2. 所谓动态通知，体现在上面方法的 DynamicInterceptionAdvice 部分，这些通知调用时因为要为通知方法**绑定参数**，还需再次利用切点表达式
3. 动态通知调用复杂程度高，性能较低