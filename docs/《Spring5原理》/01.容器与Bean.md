---
title: 容器与Bean
date: 2023-07-30 20:45:35
permalink: /pages/f344d070a1033aef
author: cynicism
categories:
  - 《Spring5原理》
tags:
  - spring
---
## 1. 容器接口
![](https://cdn.jsdelivr.net/gh/Cynicism-lab/MyResource@gh-pages/image/QQ截图20230727212140.4l6gdeiyd0qo.webp)

* BeanFactory 接口，是Spring的核心容器，典型功能有：
  * getBean——获取容器中的bean
  * **控制反转**、基本的**依赖注入**、直至 Bean 的**生命周期**的各种功能，都由它的实现类提供
  * 成员变量 singletonObjects，内部包含了所有的单例 bean

* ApplicationContext 接口，是 BeanFactory 的子接口。它扩展了 BeanFactory 接口的功能，如：
  * 国际化——**MessageSource**
  * 通配符方式获取一组 Resource 资源——**ResourcePatternResolver**
  * 整合 Environment 环境（能通过它获取各种来源的配置信息）——**EnvironmentCapable**
  * 事件发布与监听，实现组件之间的解耦——**ApplicationEventPublisher**

## 2. 容器实现
* DefaultListableBeanFactory，是 BeanFactory 最重要的实现，像**控制反转**和**依赖注入**功能，都是它来实现
* ClassPathXmlApplicationContext，从类路径查找 XML 配置文件，创建容器（旧）
* FileSystemXmlApplicationContext，从磁盘路径查找 XML 配置文件，创建容器（旧）
* XmlWebApplicationContext，传统 SSM 整合时，基于 XML 配置文件的容器（旧）
* AnnotationConfigWebApplicationContext，传统 SSM 整合时，基于 java 配置类的容器（旧）
* **AnnotationConfigApplicationContext**，Spring boot 中非 web 环境容器（新）
* **AnnotationConfigServletWebServerApplicationContext**，Spring boot 中 servlet web 环境容器（新）
* AnnotationConfigReactiveWebServerApplicationContext，Spring boot 中 reactive web 环境容器（新）

🔎另外要注意的是，后面这些带有 ApplicationContext 的类都是 ApplicationContext 接口的实现，但它们是**组合**了 DefaultListableBeanFactory 的功能，并非继承而来

**收获💡**
>beanFactory是DefaultListableBeanFactory实现的容器

* beanFactory 可以通过 registerBeanDefinition 注册一个 bean definition 对象
  * 我们平时使用的配置类、xml、组件扫描等方式都是生成 bean definition 对象注册到 beanFactory 当中
  * bean definition 描述了这个 bean 的创建蓝图：scope 是什么、用构造还是工厂创建、初始化销毁方法是什么，等等
* beanFactory 需要手动调用 **beanFactory 后处理器**对它做增强
  * 例如通过解析 @Bean、@ComponentScan 等注解，来补充一些 bean definition（第三方bean）
* beanFactory 需要手动添加 **bean 后处理器**，以便对后续 bean 的创建过程提供增强
  * 例如 @Autowired，@Resource 等注解的解析都是 bean 后处理器完成的
  * bean 后处理的添加顺序会对解析结果有影响，@Autowired比@Resource先生效
* beanFactory 需要手动调用方法来初始化单例
* beanFactory 需要额外设置才能解析 ${} 与 #{}

## 3. Bean的生命周期
一个受 Spring 管理的 bean，生命周期主要阶段有

1. **创建**：根据 bean 的构造方法或者工厂方法来创建 bean 实例对象
2. **依赖注入**：根据 @Autowired，@Value 或其它一些手段，为 bean 的成员变量填充值、建立关系
3. **初始化**：回调各种 Aware 接口，调用对象的各种初始化方法
4. **销毁**：在容器关闭时，会销毁所有单例对象（即调用它们的销毁方法）
   * prototype 对象也能够销毁，不过需要容器这边主动调用

>生命周期中还有一类 bean 后处理器：BeanPostProcessor，会在 bean 的各个生命周期的前后，提供一些扩展逻辑

创建前后的增强
* postProcessBeforeInstantiation
  * 这里返回的对象若不为 null 会替换掉原本的 bean，并且仅会走 postProcessAfterInitialization 流程
* postProcessAfterInstantiation
  * 这里如果返回 false 会跳过依赖注入阶段

依赖注入前的增强
* postProcessProperties
  * 如 @Autowired、@Value、@Resource 

初始化前后的增强
* postProcessBeforeInitialization
  * 这里返回的对象会替换掉原本的 bean
  * 如 @PostConstruct、@ConfigurationProperties
* postProcessAfterInitialization 
  * 这里返回的对象会替换掉原本的 bean
  * 如代理增强

销毁之前的增强
* postProcessBeforeDestruction
  * 如 @PreDestroy 
  
## 4. Bean 后处理器
>@Autowired 等注解的解析属于 bean 生命周期阶段（依赖注入, 初始化）的扩展功能，这些扩展功能由 bean 后处理器来完成

1. 每个后处理器各自增强什么功能
   * **AutowiredAnnotationBeanPostProcessor** 解析 @Autowired 与 @Value
   * **CommonAnnotationBeanPostProcessor** 解析 @Resource、@PostConstruct、@PreDestroy
   * **ConfigurationPropertiesBindingPostProcessor** 解析 @ConfigurationProperties
2. 另外 ContextAnnotationAutowireCandidateResolver 负责获取 @Value 的值，解析 @Qualifier、泛型、@Lazy 等

**补充：AutowiredAnnotationBeanPostProcessor依赖注入原理**
1. AutowiredAnnotationBeanPostProcessor.findAutowiringMetadata 用来获取某个 bean 上加了 @Value @Autowired 的成员变量，方法参数的信息，表示为 InjectionMetadata
2. InjectionMetadata 可以完成依赖注入
3. InjectionMetadata 内部根据成员变量，方法参数封装为 DependencyDescriptor 类型
4. 有了 DependencyDescriptor，就可以利用 beanFactory.doResolveDependency 方法进行基于类型的查找

## 5. BeanFactory 后处理器
>@ComponentScan, @Bean, @Mapper 等注解的解析属于核心容器（即 BeanFactory）的扩展功能，主要就是补充了一些 bean 定义

* ConfigurationClassPostProcessor 可以解析
  * @ComponentScan
  * @Bean
  * @Import
  * @ImportResource
* MapperScannerConfigurer 可以解析
  * Mapper 接口

### 5.1 @ComponentScan解析
1. Spring 操作元数据的工具类 CachingMetadataReaderFactory
2. 通过**注解元数据**（AnnotationMetadata）获取直接(@Component)或间接(Controller)标注的注解信息
3. 通过**类元数据**（ClassMetadata）获取类名，AnnotationBeanNameGenerator 生成 bean 名
4. 解析元数据是基于 ASM 技术 (**Java字节码操作框架**)

>ASM是一个强大的字节码工具，用于分析、修改和生成Java类文件的字节码。它可以让开发者在运行时动态地检查和操作类的结构、字段、方法以及注解等元数据信息。
通过ASM，开发者可以利用字节码级别的操作来解析和处理类的元数据。例如，可以使用ASM来提取类的注解信息，获取类的字段和方法信息，甚至可以修改字节码来添加、修改或删除元数据。

### 5.2 @Mapper解析
1. Mapper 接口被 Spring 管理的本质：实际是被作为 **MapperFactoryBean** 注册到容器中
2. Spring 的诡异做法，根据接口生成的 BeanDefinition 仅为根据接口名生成 bean 名

## 6. Aware 接口
1. Aware 接口提供了一种【内置】 的注入手段，例如
   * BeanNameAware 注入 bean 的名字
   * BeanFactoryAware 注入 BeanFactory 容器
   * ApplicationContextAware 注入 ApplicationContext 容器
   * EmbeddedValueResolverAware 注入 ${} 解析器
2. InitializingBean 接口提供了一种【内置】的初始化（相当于构造函数初始化）
3. 对比
   * 内置的注入和初始化不受扩展功能的影响，**总会被执行**
   * 而扩展功能受某些情况影响**可能会失效**
   * 因此 Spring 框架内部的类常用内置注入和初始化

## 7. 初始化与销毁
Spring 提供了多种初始化手段，除了课堂上讲的 @PostConstruct，@Bean(initMethod) 之外，还可以实现 InitializingBean 接口来进行初始化，如果同一个 bean 用了以上手段声明了 3 个初始化方法，那么它们的执行顺序是

1. @PostConstruct 标注的初始化方法
2. InitializingBean 接口的初始化方法
3. @Bean(initMethod) 指定的初始化方法

与初始化类似，Spring 也提供了多种销毁手段，执行顺序为
1. @PreDestroy 标注的销毁方法
2. DisposableBean 接口的销毁方法
3. @Bean(destroyMethod) 指定的销毁方法

## 8. Scope 
在当前版本的 Spring 和 Spring Boot 程序中，支持五种 Scope
* singleton，容器启动时创建（未设置延迟），容器关闭时销毁
* prototype，每次使用时创建，不会自动销毁，需要调用 DefaultListableBeanFactory.destroyBean(bean) 销毁
* request，每次请求用到此 bean 时创建，请求结束时销毁（web）
* session，每个会话用到此 bean 时创建，会话结束时销毁（web）
* application，web 容器用到此 bean 时创建，容器停止时销毁（web）

>🔎如果在 singleton 注入其它 scope 都会有问题，解决方法有

* @Lazy（依赖注入时使用）
* @Scope(proxyMode = ScopedProxyMode.TARGET_CLASS)
* ObjectFactory
* ApplicationContext.getBean

**分析失效原因：**
![](https://cdn.jsdelivr.net/gh/Cynicism-lab/MyResource@gh-pages/image/QQ截图20230730195342.6j0xhd33ksu8.webp)

