---
title: JVM调优
date: 2024-06-03 
permalink: /pages/ff55d070a3333fh
author: cynicism
categories:
  - 《JVM》笔记
tags:
  - jvm
---

> **性能监控 -----》性能分析------》性能调优**

## 1. 性能监控(发现问题)
| 具体问题      | 监控工具 |
| ---------     | ------|
|GC频繁         | jstat |
| CPU占用过高   | jstat   |
| OOM           | jmap   |
| 内存泄露      | jmap   |
| 死锁（线程）          | jstack  |
| 程序响应时间过长（线程） | jstack  |

## 2. 命令行指令
- **jps**：查看正在运行的java进程
- **jstat**：可以**持续监视**虚拟机各种运行状态信息，包括类加载、**内存**、**垃圾收集**等运行时数据
- **jmap**：导出**当前时刻**的内存映像文件（dump二进制文件）和内存使用情况
- **jstack**：生成**当前时刻**的线程快照（线程正在执行的方法堆栈集合以及执行状态）

>可视化工具：Visual VM

## 3. 评价指标
- **停顿时间**
  - 应用程序中指的是提交请求和返回请求的响应之间使用的时间；
  - GC中指的是暂停工作线程的时间

- **吞吐量**
    - 单位时间内完成的工作量
    - GC中指的是运行用户代码的时间占总运行时间的比例


## 4. 内存泄漏
::: note 定义
内存中**一直存在**，但是**不再被使用**的**对象**
:::

1. **静态集合类**
```java
public class Test {
    // list即为静态集合类
    static List<String> list = new ArrayList<>();

    public void oomTest(){
        String str = new String("test");
        list.add(str);
    }
}
```
>长生命周期的对象（**静态集合类**）持有短生命周期的对象（例子中的**局部对象**）的引用，导致短生命周期的对象无法被回收

2. **单例模式**
>与静态集合类的原因相似，如果单例对象持有外部对象的引用，导致外部对象也无法回收

3. **连接未关闭**
> 各种连接，如数据库连接、网络连接、文件流等，如果没有关闭，就会造成内存泄漏

4. **变量不合理的作用域**
> 变量定义的作用范围大于其使用范围，例如该变量只在某个方法内被使用，导致变量无法被回收（与对象的生命周期相同），造成内存泄漏

5. **缓存泄露**
> 把对象引用放入缓存中，容易被遗忘，尽管进行了GC，这些对象无法被回收，导致内存泄漏，<mark>解决方案：使用WeakHashMap代表缓存</mark>





