---
title: 内存结构
date: 2023-08-31 20:45:35
permalink: /pages/ff55d070a1033aef
author: cynicism
categories:
  - 《JVM》笔记
tags:
  - jvm
---
## 1. 什么是 JVM ？
>HotSpot 版本的虚拟机

- 一次编译，处处执行
- 自动的内存管理，垃圾回收机制
- 数组下标越界检查

![](https://cdn.staticaly.com/gh/Cynicism-lab/MyResource@gh-pages/image/20210207154634171.99svzyjz0p.webp)

**内存结构模型**
![](https://cdn.staticaly.com/gh/Cynicism-lab/MyResource@gh-pages/image/20210207155820178.6d2rr2a2oxs0.webp)

- ClassLoader：Java 代码编译成二进制后，会经过类加载器，这样才能加载到 JVM 中运行。
- Method Area：类是放在方法区中。
- Heap：类的实例对象。
- 当类调用方法时，会用到 JVM Stack、PC Register、本地方法栈。
- 方法执行时的每行代码是有执行引擎中的解释器逐行执行，方法中的热点代码频繁调用的方法，由 JIT 编译器优化后执行，GC 会对堆中不用的对象进行回收。需要和操作系统打交道就需要使用到本地方法接口。

## 2. 内存结构
### 2.1 程序计数器
>记录下一条 jvm 指令的执行地址

- 是线程私有的
- 不会存在内存溢出

### 2.2 虚拟机栈
- 每个线程运行需要的内存空间，称为虚拟机栈
- 每个栈由多个栈帧（Frame）组成，对应着每次调用方法时所占用的内存
- 每个线程只能有一个活动栈帧，对应着当前正在执行的方法

**问题辨析：**
- 垃圾回收是否涉及栈内存？
不会。栈内存是方法调用产生的，方法调用结束后会弹出栈。
    
- 栈内存分配越大越好吗？
不是。因为物理内存是一定的，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。
    
- 方法呢的局部变量是否线程安全？
如果方法内部的变量没有逃离方法的作用访问，它是线程安全的
如果是局部变量引用了对象，并逃离了方法的访问，那就要考虑线程安全问题。

### 2.3 本地方法栈
一些带有 **native** 关键字的方法就是需要 JAVA 去调用本地的C或者C++方法，因为 JAVA 有时候没法直接和操作系统底层交互，所以需要用到本地方法栈，服务于带 native 关键字的方法。

### 2.4 堆
>通过new关键字创建的对象都会被放在堆内存

- 它是线程共享，堆内存中的对象都需要考虑线程安全问题
- 有垃圾回收机制

### 2.5 方法区
#### 2.5.1 定义
>Java 虚拟机有一个在所有 Java 虚拟机**线程之间共享的方法区域**。

方法区域类似于用于传统语言的编译代码的存储区域，或者类似于操作系统进程中的“文本”段。它存储**每个类的结构**，例如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括特殊方法，用于类和实例初始化以及接口初始化方法区域是在虚拟机启动时创建的。

#### 2.5.2 组成
![](https://cdn.staticaly.com/gh/Cynicism-lab/MyResource@gh-pages/image/20210208112903305.2v1cp0svipxc.webp)

#### 2.5.3 运行时常量池
**常量池：**
就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息  
**运行时常量池：**
常量池是 *.class 文件中的，当该类被加载以后，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址

#### 2.5.4 StringTable
- 常量池中的字符串仅是符号，只有在被用到时才会转化为对象
- 利用串池的机制，来避免重复创建字符串对象
- 字符串**变量拼接**的原理是StringBuilder
- 字符串**常量拼接**的原理是编译器优化
- 可以使用intern方法，主动将串池中还没有的字符串对象放入串池中

>调用字符串对象的 intern 方法，会将该字符串对象尝试放入到串池中
,如果串池中没有该字符串对象，则放入成功如果有该字符串对象，则放入失败,无论放入是否成功，都会返回串池中的字符串对象

#### 2.5.5 StringTable 性能调优
- 因为StringTable是由HashTable实现的，所以可以适当增加HashTable桶的个数，来减少字符串放入串池所需要的时间

>-XX:StringTableSize=桶个数（最少设置为 1009 以上）

- 考虑是否需要将字符串对象入池
>可以通过 intern 方法减少重复入池

### 2.6 直接内存
#### 2.6.1 定义
- 常见于 NIO 操作时，用于数据缓冲区
- 分配回收成本较高，但读写性能高
- 不受 JVM 内存回收管理

#### 2.6.2 对比
**常规文件读写流程：**  
因为 java 不能直接操作文件管理，需要切换到内核态，使用本地方法进行操作，然后读取磁盘文件，会在系统内存中创建一个缓冲区，将数据读到系统缓冲区， 然后在将系统缓冲区数据，复制到 java 堆内存中。缺点是数据存储了两份，在系统内存中有一份，java 堆中有一份，造成了不必要的复制。
![](https://cdn.staticaly.com/gh/Cynicism-lab/MyResource@gh-pages/image/20210208180041113.5fsnshzcghkw.webp)

**使用了 DirectBuffer 文件读取流程**  
直接内存是操作系统和 Java 代码都可以访问的一块区域，无需将代码从系统内存复制到 Java 堆内存，从而提高了效率。
![](https://cdn.staticaly.com/gh/Cynicism-lab/MyResource@gh-pages/image/20210208181022863.4ymwbfvna4u8.webp)

**直接内存的回收机制总结**
- 使用了 Unsafe 类来完成直接内存的分配回收，回收需要主动调用freeMemory 方法
- ByteBuffer 的实现内部使用了 Cleaner（虚引用）来检测 ByteBuffer 。一旦ByteBuffer 被垃圾回收，那么会由 ReferenceHandler（守护线程） 来调用 Cleaner 的 clean 方法调用 freeMemory 来释放内存


