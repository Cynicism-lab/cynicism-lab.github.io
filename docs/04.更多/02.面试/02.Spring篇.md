---
title: Spring篇
date: 2024-01-12 12:57:34
permalink: /pages/5e703d/
categories:
  - 更多
  - 面试
tags:
  - 
author: 
  name: cynicism
  link: https://github.com/cynicism-lab
---
## 1. Spring mvc处理一个请求的过程
![](https://cdn.jsdelivr.net/gh/Cynicism-lab/MyResource/img/mvc.png)

1. 客户端浏览器将发出的请求封装为一个**HttpServletRequest对象**，转交请求给服务器
2. 服务器收到请求后，转交请求给**Web容器（Tomcat）**，Web容器调用Servlet处理请求。在Spring MVC中，这个Servlet就是**前端控制器DispatcherServlet**
3. DispatcherServlet收到请求后，调用**HandlerMapping处理器映射器**。处理器映射器根据请求Url找到**具体的Handler（后端控制器）**，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet
4. DispatcherServlet调用**HandlerAdapter处理器适配器**去调用Handler。处理器适配器执行Handler，也就是执行我们的Controller层的业务逻辑。
5. 最后，处理完业务逻辑后，**返回ModelAndView对象**，DispatcherServlet会将ModelAndView对象传给**ViewResolver视图解析器进行解析**，解析后返回对应的View

## 2. 过滤器和拦截器的区别
>过滤器（Filter）和拦截器（Interceptor）都是**基于AOP（面向切面编程）思想实现**

1. 实现机制：拦截器是基于Java的反射机制的，而过滤器是基于函数回调
2. 依赖性：拦截器(Spring组件)不依赖于Servlet容器，而过滤器依赖于Servlet容器(只适用于web程序)
3. 过滤器是在请求进入容器后，但请求进入servlet之前进行预处理的，所以filter的入参是RequestServlet。请求结束返回也是，是在servlet处理完后，返回给前端之前。如下图
而拦截器的入参是HttpRequestServlet

![](https://cdn.jsdelivr.net/gh/Cynicism-lab/MyResource/img/20200602173814901.png)

>Web容器启动时，是先加载完所有的Bean，在进行监听器-》过滤器-》拦截器注册，所以都能获取到IOC容器中的Bean，也就是说可以在执行过程中调用业务逻辑

## 3. Concurrenthashmap如何实现互斥的？
ConcurrentHashMap是Java中的一个线程安全的HashMap，它允许多个线程并发访问哈希表，并发修改map中的数据而不会产生死锁。ConcurrentHashMap的互斥主要通过以下几种方式实现：

- **分段锁**（Segment Locking）：ConcurrentHashMap的对象被分为多个段，每个段都有自己的锁。这意味着多个线程可以同时更新ConcurrentHashMap，只要它们更新的是不同的段。这种机制提高了并发性，因为在更新时不需要锁定整个HashMap。

- **原子操作**：ConcurrentHashMap提供了一些原子操作的方法，如putIfAbsent(), replace(), 和 remove()。这些方法可以确保在执行操作时不会被其他线程中断。

- **不允许使用null**：ConcurrentHashMap不允许使用null作为键或值。这可以避免出现在多线程环境中的空指针异常。




