---
title: 项目篇
date: 2024-01-19 12:57:34
permalink: /pages/6571b5e7da/
categories:
  - 更多
  - 面试
tags:
  - 面经
author: 
  name: cynicism
  link: https://github.com/cynicism-lab
---
## 1. 分布式ID的生成策略
- UUID：UUID是一种常见的本地生成ID的方法，它有着全球唯一的特性。但UUID过长，往往用字符串表示，作为主键建立索引查询效率低
- 数据库自增ID：基于数据库的auto_increment自增ID完全可以充当分布式ID，但访问量激增时MySQL本身就是系统的瓶颈，用它来实现分布式服务风险比较大
数据库多主模式：对上述数据库自增ID方式做一些高可用优化，换成主从模式集群。但如果集群后的性能还是扛不住高并发，就需要进行MySQL扩容增加节点
- Redis：Redis也同样可以实现，原理就是利用redis的incr命令实现ID的原子性自增
- Twitter的Snowflake算法：Snowflake是Twitter开源的分布式ID生成算法，其核心思想为，一个long型的ID：41 bit作为毫秒数，10 bit作为机器编号，12 bit作为毫秒内序列号

## 2. 线程池有哪些问题？
- **资源消耗**：线程池需要维护一组线程，这些线程在空闲时仍然占用系统资源。如果线程池中的线程数量过多，可能会导致内存和CPU资源的浪费。
- **线程泄漏**：如果线程池中的线程没有正确地释放，可能会导致线程泄漏。这会增加系统的负担并降低性能。
- **死锁**：线程池中的任务可能会相互等待，导致死锁。例如，如果一个任务等待另一个任务完成，而后者又在等待第一个任务完成，就会出现死锁。
- **拒绝策略不当**：线程池满载时，如果没有合适的拒绝策略，可能会导致任务被丢弃或系统崩溃。
- **任务执行时间不均衡**：如果线程池中的某些任务执行时间过长，可能会影响其他任务的执行速度。
- **线程安全问题**：线程池中的共享资源可能会出现竞争条件，需要谨慎处理同步和互斥。

## 3. Spring Security的优缺点
**优点**：
- 易于使用：Spring Security 提供了许多现成的功能和配置选项，使其易于集成到应用程序中。
- Java 集成：作为 Java 生态系统的一部分，Spring Security与其他 Spring 框架（如 Spring Boot、Spring MVC）无缝集成。
- 灵活性：Spring Security 可以轻松扩展以满足自定义需求。您可以自定义身份验证和授权逻辑。
- 全面的 Servlet API 集成：Spring Security 可以与 Servlet API 集成，包括基于 URL 的安全性、会话管理等。
- 防御攻击：Spring Security 提供了保护机制，防止跨站点请求伪造（CSRF）、跨站点脚本（XSS）等攻击。
  
**缺点**：
- 文档不足：Spring Security 的文档可能不足以处理某些安全威胁，例如跨站点脚本（XSS）。开发人员需要额外的资源来了解和应用最佳实践。
- 复杂性：尽管 Spring Security 提供了许多功能，但它的配置和使用可能会变得复杂，特别是对于初学者。
- 学习曲线：对于没有经验的开发人员，学习 Spring Security 可能需要一些时间。

## 4. java8新特性
- **Lambda 表达式**：Lambda 允许将函数作为方法的参数传递，使代码更简洁、紧凑。
- **函数式接口**：函数式接口指的是只有一个抽象方法的接口，可以隐式转换为 Lambda 表达式。
- **方法引用**：方法引用允许直接引用已有 Java 类或对象的方法或构造器，使代码更简洁。
- **默认方法**：接口中可以有默认实现的方法，方便接口的扩展。
- **Stream API**：Stream API 引入了函数式编程风格，用于处理集合数据。

## 5. 用于实现功能扩展的设计模式
- **装饰者模式**：装饰者模式允许我们在运行时动态地为对象添加新的行为。通过将装饰器包裹在原始对象周围，我们可以逐步添加功能，而不影响原始类的结构。这对于实现功能扩展非常有用
- **策略模式**：策略模式允许我们定义一系列算法，并将其封装成独立的类。通过在运行时选择不同的策略，我们可以实现不同的功能扩展。例如，根据不同的需求选择不同的排序算法
- **观察者模式**：观察者模式用于实现对象之间的一对多依赖关系。当一个对象的状态发生变化时，所有依赖于它的对象都会得到通知。这对于实现功能扩展和事件处理非常有用

## 6. Mysql的分布式事务
>在MySQL数据库中，分布式事务是一种用于管理多个数据库之间的数据一致性和事务处理的技术。它主要通过两种方式实现：**两阶段提交**（Two-Phase Commit，2PC）和**基于消息的事务性**（X/Open XA）

- **两阶段提交**：这是一种基于协调者和参与者的分布式事务处理协议。在第一阶段，协调者会向所有参与者发送准备命令，参与者在接收到准备命令后，会执行事务操作，并将操作结果保存在本地，然后向协调者报告准备就绪。在第二阶段，如果协调者收到所有参与者的准备就绪消息，那么它会向所有参与者发送提交命令，参与者在接收到提交命令后，会提交事务，并释放在第一阶段中锁定的资源
  
- **基于消息的事务性**：这是一种通过消息队列来实现分布式事务的方法。在这种方法中，一个服务会在本地数据库中执行事务操作，并将操作结果发送到消息队列中。其他服务可以从消息队列中读取消息，并根据消息内容在本地数据库中执行相应的事务操作。这种方法的优点是可以确保所有服务的数据一致性，缺点是需要维护一个消息队列，增加了系统的复杂性。

## 7. 一致性哈希
一致性哈希（Consistent Hashing）是一种特殊的哈希算法，用于解决分布式系统中的数据分片问题。它的主要目标是在系统扩容和缩容时，最小化数据迁移量，从而减轻系统负载，保证系统的高可用性。

一致性哈希的基本思想是将哈希值域组成一个虚拟的环（也称为哈希环），然后将数据和节点（机器）映射到这个环上。当需要查找某个键（key）对应的值（value）时，可以沿着环的方向查找，直到遇到的第一个节点，该节点就是该键对应的值所在的位置。

一致性哈希的一个重要特性是，当增加或删除节点时，只需要对环上的一小部分数据进行重新映射，而不需要对所有数据进行重新映射。这就大大减少了在节点动态变化时所需的数据迁移量，从而提高了系统的稳定性和效率

## 8. 如何实现全局异常处理器
在Spring Boot中，全局异常处理可以通过使用`@ControllerAdvice`注解来实现。这个注解可以让我们在一个独立的类中定义全局的异常处理方法

`@ExceptionHandler(value = Exception.class)`注解表示这个方法用于处理所有类型的异常。当发生异常时，Spring会自动调用这个方法，并将异常对象作为参数传入，然后我们可以在这个方法中处理异常

## 9. 线程池的拒绝策略
- **AbortPolicy**：这是线程池的默认拒绝策略。当任务被拒绝时，AbortPolicy会直接抛出一个类型为RejectedExecutionException的RuntimeException
- DiscardPolicy：这种拒绝策略会直接丢弃被拒绝的任务，但是不会抛出异常
- DiscardOldestPolicy：这种策略会丢弃任务队列中最旧的任务（即最先进入队列的，最久未处理的任务），然后尝试重新提交新的任务
- CallerRunsPolicy：这种策略下，如果线程池未关闭，对于新提交的任务，它是由调用者所在的线程来处理

## 10. Spring Security的实现原理
Spring Security的具体工作原理如下：
1.用户请求Web应用程序的受保护资源。
2.Spring Security拦截请求，并尝试获取用户的身份验证信息。
3.如果用户没有经过身份验证，Spring Security将向用户显示一个登录页面，并要求用户提供有效的凭据（用户名和密码
4.一旦用户提供了有效的凭据，Spring Security将验证这些凭据，并创建一个已认证的安全上下文（SecurityContext）对象
5.安全上下文对象包含已认证的用户信息，包括用户名、角色和授权信息。
6.在接下来的请求中，Spring Security将使用已经认证的安全上下文对象来判断用户是否有权访问受保护的资源
7.如果用户有权访问资源，Spring Security将允许用户访问资源，否则将返回一个错误信息

## 11. 常见异常类
- ArithmeticException：在数值计算过程中发生的异常，例如除零错误
- NullPointerException：当应用程序试图在需要对象的地方使用 null 时引发的异常
- ArrayIndexOutOfBoundsException：当对数组的索引值为负数或大于等于数组大小时抛出
- ClassCastException：当一个不是该类的实例转换成这个类就会抛出这个异常
- ClassNotFoundException：未能找到指定的类，比如使用 Class.forName () 时指定的类名不正确
- IOException：输入输出操作异常，比如文件读写错误
- SQLException：SQL 操作异常，比如连接数据库错误
- FileNotFoundException：找不到文件异常，如果文件不存在就会抛出这种异常
- NoSuchMethodException：方法不存在异常，当应用试图调用某类的某个方法，而该类的定义中没有该方法的定义时抛出该错误

## 12. 分治法 vs 动态规划
**相同点**：两者都要求原问题具有最优子结构性质，都是将原问题分而治之，分解成若干个规模较小的子问题，然后将子问题的解合并，形成原问题的解

**不同点**：
- 分治法将分解后的子问题看成相互独立的，通过用递归实现
- 动态规划将分解后的子问题理解为相互间有联系，有重叠部分，需要记忆，通常用迭代实现

## 13. 消息队列的使用场景
- **异步处理**：例如，用户注册后，需要发送注册邮件和注册短信。传统的做法是将注册信息写入数据库成功后，发送注册邮件，再发送注册短信。使用了消息队列，可以将这些非必须的业务逻辑异步处理，提高系统响应速度
- **应用解耦**：例如，用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。引入消息队列后，可以实现订单系统与库存系统的应用解耦，提高系统稳定性
- **流量削峰**：例如，在秒杀或团抢活动中，由于流量过大，导致流量暴增，应用挂掉。引入消息队列，可以控制活动的人数，缓解短时间内高流量压垮应用
- **日志处理**：例如，分布式系统的日志数据庞大且分散，消息队列可用于集中日志信息。各服务将日志发送到队列，专门的日志收集服务负责从队列中读取并进行存储、分析和报警
- **消息通讯**：例如，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等
  
## 13. 如何保证消息队列的有序性
消息队列的有序性是指消息在生产者发送到消费者的过程中，消息的顺序保持不变。以下是一些常见的方法来保证消息队列的有序性：

1. **单一队列**：将所有相关消息都发送到同一个队列中，并且确保消费者按顺序处理这些消息。这种方式简单直接，但可能在高负载情况下成为瓶颈

2. **创建多个队列**：对于RabbitMQ，我们可以给RabbitMQ创建多个queue，每个消费者固定消费一个queue的消息，生产者发送消息的时候，同一个订单号的消息发送到同一个queue中，由于同一个queue的消息是一定会保证有序的，那么同一个订单号的消息就只会被一个消费者顺序消费，从而保证了消息的顺序性










