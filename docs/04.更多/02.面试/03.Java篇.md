---
title: Java篇
date: 2024-01-12 12:57:34
permalink: /pages/5e703d/
categories:
  - 更多
  - 面试
tags:
  - 
author: 
  name: cynicism
  link: https://github.com/cynicism-lab
---
## 1. Map中如何清理大对象？
1. 手动删除
```java
map.remove(key); // 删除指定的键值对
map.clear(); // 清空整个 Map
```

>如果Map中存储的是对象的引用（尤其是大对象），那么即使Map被清空，这些对象也不会被立即回收，除非没有其他引用指向它们

2. 使用迭代器
如果Map中存储的是大对象的引用，并且这些对象需要在清空Map后立即被回收，那么可以使用迭代器遍历Map，并显式地将每个元素设为null。这样可以确保对象被立即回收


## 2. 守护线程不结束怎么办
::: note 守护线程（Daemon Thread）
它是一种特殊的线程，主要用于为其他线程提供服务，例如垃圾回收线程，守护线程不结束可能是因为非守护线程还在运行
:::
1. 结束所有非守护线程：由于守护线程会在所有非守护线程结束后自动销毁，因此你可以尝试结束所有非守护线程

2. 使用interrupt()方法：你可以尝试使用interrupt()方法来中断守护线程。这个方法会设置线程的中断标志，然后线程可以选择如何响应这个中断。

3. 使用stop()方法：虽然stop()方法已经被弃用，因为它可能会导致对象处于不一致的状态，但在某些情况下，你可能需要使用它来强制结束线程。但请注意，这应该是最后的手段，因为使用stop()方法可能会导致严重的问题。

## 3. ThreadLocal原理
ThreadLocal是Java中的一个特殊变量，它可以**为每个线程创建一个独立的变量副本**。以下是ThreadLocal的工作原理：

- ThreadLocalMap：每个Thread都有一个ThreadLocalMap，它是一个Map型的数据结构，实际的值就是保存在这里面。ThreadLocalMap以ThreadLocal作为key，value就是ThreadLocal的值。

- 弱引用：ThreadLocalMap中的**key是对ThreadLocal的弱引用**。这意味着，如果没有其他强引用指向ThreadLocal对象，那么这个ThreadLocal对象就会被垃圾回收器回收。

>🔎关于ThreadLocal的key被垃圾回收是否会造成内存泄漏，答案是可能的。

当ThreadLocal对象被垃圾回收器回收后，**ThreadLocalMap中对应的key会变为null，但是value还在**，因为它仍然被ThreadLocalMap中的Entry强引用。只有当Thread结束，ThreadLocalMap才会被销毁，value才会被回收。因此，如果Thread一直不结束，这些value就会一直存在，可能会导致内存泄漏。

>💡为了避免这种情况，最好的做法是每次使用完ThreadLocal后，都调用它的remove()方法，清除当前线程的value。这样可以确保ThreadLocal不再被使用时，不会有value被遗留在ThreadLocalMap中。

